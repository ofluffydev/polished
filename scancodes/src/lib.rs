//! PS/2 Keyboard Scancode to Keysym/ASCII Mapping Library
//!
//! This module provides translation from PS/2 Set 1 keyboard scancodes (as generated by the keyboard controller and delivered via PS/2/IRQ1)
//! to symbolic key representations (`Keysym`) and ASCII values. It is designed for use in low-level OS code where keyboard input is handled
//! via hardware interrupts and raw scancodes are received from the PS/2 controller.
//!
//! # How Scancodes Work
//!
//! When a key is pressed or released on a PS/2 keyboard, the controller sends a *scancode* byte to port 0x60, which is typically read in the
//! keyboard interrupt handler (IRQ1). The scancode identifies which key was pressed or released, but does not directly correspond to ASCII.
//!
//! This module uses the standard PS/2 Set 1 scancode set (used by most PC keyboards in legacy mode). Each scancode is mapped to a `u16` value:
//!   - For printable keys, this is the ASCII code (e.g., 'A' as u16).
//!   - For special keys (Ctrl, Shift, Fn, etc.), a unique code is used (e.g., 0x0100 for Left Ctrl).
//!
//! # Usage
//! - Use `scancode_to_keysym` to convert a scancode to a symbolic key value.
//! - Use `scancode_to_ascii` to convert a scancode to an ASCII byte (if possible).
//!
//! # Limitations
//! - Only Set 1 scancodes are supported.
//! - Extended keys (E0/E1 prefix) and key release events are not handled here.
//! - This table is designed for US QWERTY layout.
//!
//! # Safety
//! This module is `#![no_std]` and suitable for use in kernel/bootloader code.

#![no_std]

/// Lookup table for PS/2 Set 1 scancodes to keysyms/ASCII.
///
/// The index is the scancode (0-88). Values are:
///   - ASCII code for printable keys
///   - Special codes for modifiers and function keys
///   - 0 for unknown/unused scancodes
static PS2_SET1: [u16; 89] = [
    0,             // 0x00: Unknown
    0x1B,          // 0x01: Escape
    '1' as u16,    // 0x02: '1'
    '2' as u16,    // 0x03: '2'
    '3' as u16,    // 0x04: '3'
    '4' as u16,    // 0x05: '4'
    '5' as u16,    // 0x06: '5'
    '6' as u16,    // 0x07: '6'
    '7' as u16,    // 0x08: '7'
    '8' as u16,    // 0x09: '8'
    '9' as u16,    // 0x0A: '9'
    '0' as u16,    // 0x0B: '0'
    '-' as u16,    // 0x0C: '-'
    '=' as u16,    // 0x0D: '='
    '\x08' as u16, // 0x0E: Backspace
    '\t' as u16,   // 0x0F: Tab
    'Q' as u16,    // 0x10: 'Q'
    'W' as u16,    // 0x11: 'W'
    'E' as u16,    // 0x12: 'E'
    'R' as u16,    // 0x13: 'R'
    'T' as u16,    // 0x14: 'T'
    'Y' as u16,    // 0x15: 'Y'
    'U' as u16,    // 0x16: 'U'
    'I' as u16,    // 0x17: 'I'
    'O' as u16,    // 0x18: 'O'
    'P' as u16,    // 0x19: 'P'
    '[' as u16,    // 0x1A: '['
    ']' as u16,    // 0x1B: ']'
    '\n' as u16,   // 0x1C: Enter
    0x0100,        // 0x1D: KeyCtrlLeft
    'A' as u16,    // 0x1E: 'A'
    'S' as u16,    // 0x1F: 'S'
    'D' as u16,    // 0x20: 'D'
    'F' as u16,    // 0x21: 'F'
    'G' as u16,    // 0x22: 'G'
    'H' as u16,    // 0x23: 'H'
    'J' as u16,    // 0x24: 'J'
    'K' as u16,    // 0x25: 'K'
    'L' as u16,    // 0x26: 'L'
    ';' as u16,    // 0x27: ';'
    '\'' as u16,   // 0x28: '''
    '`' as u16,    // 0x29: '`'
    0x0200,        // 0x2A: KeyShiftLeft
    '\\' as u16,   // 0x2B: '\'
    'Z' as u16,    // 0x2C: 'Z'
    'X' as u16,    // 0x2D: 'X'
    'C' as u16,    // 0x2E: 'C'
    'V' as u16,    // 0x2F: 'V'
    'B' as u16,    // 0x30: 'B'
    'N' as u16,    // 0x31: 'N'
    'M' as u16,    // 0x32: 'M'
    ',' as u16,    // 0x33: ','
    '.' as u16,    // 0x34: '.'
    '/' as u16,    // 0x35: '/'
    0x0300,        // 0x36: KeyShiftRight
    0x0400,        // 0x37: KeyPad('*')
    0x0500,        // 0x38: KeyAltLeft
    ' ' as u16,    // 0x39: Space
    0x0600,        // 0x3A: KeyCapsLock
    0x0701,        // 0x3B: KeyFn(1)
    0x0702,        // 0x3C: KeyFn(2)
    0x0703,        // 0x3D: KeyFn(3)
    0x0704,        // 0x3E: KeyFn(4)
    0x0705,        // 0x3F: KeyFn(5)
    0x0706,        // 0x40: KeyFn(6)
    0x0707,        // 0x41: KeyFn(7)
    0x0708,        // 0x42: KeyFn(8)
    0x0709,        // 0x43: KeyFn(9)
    0x070A,        // 0x44: KeyFn(10)
    0x0800,        // 0x45: KeyNumLock
    0x0900,        // 0x46: KeyScrollLock
    0x0417,        // 0x47: KeyPad('7')
    0x0418,        // 0x48: KeyPad('8')
    0x0419,        // 0x49: KeyPad('9')
    0x041A,        // 0x4A: KeyPad('-')
    0x0414,        // 0x4B: KeyPad('4')
    0x0415,        // 0x4C: KeyPad('5')
    0x0416,        // 0x4D: KeyPad('6')
    0x041B,        // 0x4E: KeyPad('+')
    0x0411,        // 0x4F: KeyPad('1')
    0x0412,        // 0x50: KeyPad('2')
    0x0413,        // 0x51: KeyPad('3')
    0x0410,        // 0x52: KeyPad('0')
    0x041C,        // 0x53: KeyPad('.')
    0,             // 0x54: Unknown
    0,             // 0x55: Unknown
    0,             // 0x56: Unknown
    0x070B,        // 0x57: KeyFn(11)
    0x070C,        // 0x58: KeyFn(12)
];

/// Symbolic representation of a key (keysym).
///
/// This wraps a `u16` value, which may be an ASCII code or a special code for modifiers/function keys.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Keysym(u16);

impl Keysym {
    /// Create a `Keysym` from a raw `u16` value.
    ///
    /// # Arguments
    /// * `key` - The raw `u16` value representing a key (ASCII code or special code).
    ///
    /// # Returns
    /// A `Keysym` instance wrapping the given `u16` value.
    pub fn from(key: u16) -> Self {
        Keysym(key)
    }

    /// Return a `Keysym` representing an unknown key.
    ///
    /// # Returns
    /// A `Keysym` instance that represents an unknown key (wrapped value is 0).
    pub fn key_unknown() -> Self {
        Keysym(0)
    }

    /// Check if this keysym is unknown.
    ///
    /// # Returns
    /// `true` if the keysym represents an unknown key, `false` otherwise.
    pub fn is_unknown(&self) -> bool {
        self.0 == 0
    }

    /// Get the raw `u16` value of this keysym.
    ///
    /// # Returns
    /// The wrapped `u16` value representing the keysym.
    pub fn as_u16(&self) -> u16 {
        self.0
    }
}

/// Convert a PS/2 Set 1 scancode to a `Keysym`.
///
/// # Arguments
/// * `scancode` - The raw scancode byte from the keyboard controller (port 0x60).
///
/// # Returns
/// A `Keysym` representing the key, or `Keysym::key_unknown()` if unmapped.
///
/// # Note
/// This function is intended to be called from a keyboard interrupt handler (IRQ1) after reading a scancode from the PS/2 controller.
pub fn scancode_to_keysym(scancode: u8) -> Keysym {
    if scancode as usize >= PS2_SET1.len() {
        return Keysym::key_unknown();
    }
    let key = PS2_SET1[scancode as usize];
    if key == 0 {
        return Keysym::key_unknown();
    }
    Keysym::from(key)
}

/// Convert a PS/2 Set 1 scancode to an ASCII byte, if possible.
///
/// # Arguments
/// * `scancode` - The raw scancode byte from the keyboard controller (port 0x60).
///
/// # Returns
/// `Some(ascii)` if the key is a printable ASCII character, or `None` otherwise.
///
/// # Note
/// This is useful for simple text input, but does not handle modifiers or non-ASCII keys.
pub fn scancode_to_ascii(scancode: u8) -> Option<u8> {
    if scancode as usize >= PS2_SET1.len() {
        return None;
    }
    let key = PS2_SET1[scancode as usize];
    // Accept printable ASCII and control chars (backspace, tab, LF, CR)
    if (0x20..=0x7E).contains(&key) || matches!(key, 0x08 | 0x09 | 0x0A | 0x0D) {
        Some(key as u8)
    } else {
        None
    }
}
